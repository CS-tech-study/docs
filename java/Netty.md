## Netty

기존의 소켓 프로그래밍은 클라이언트가 접속하게 되면 스레드를 할당해야 하는데(1:1관계), 정말 많은 클라이언트가 접속을 하게 될 경우 그 숫자만큼 스레드를 생성해야 해서 리소스의 낭비로 이루어지고, 문맥 교환과 관련된 문제와 입력이나 출력 데이터에 관련한 무한 대기 현상이 발생하는 문제가 있었습니다.

이러한 네트워크 문제 때문에 개발된 방법이 자바의 **NIO 방식(Non-Blocking Input Ouput)**입니다.

핵심으로는 네트워크 리소스 사용률을 세부적으로 제어하는 **Non-Blocking 호출**이 포함되어 있는 것으로, 내부적으로 시스템의 이벤트 통지 API를 이용해 논 블록킹 소켓을 등록하면 해당 소켓의 정보를 확인할 수 있습니다. 즉 무한 대기 현상을 회피할 수 있게 되는 것이지요.

기존의 소켓 통신 프로그래밍이 동기적인 네트워크 통신이었다면, NIO는 **비동기적인 네트워크 통신**이라고 보시면 됩니다.

![image](https://github.com/user-attachments/assets/104a7650-0160-4141-a580-07be5cce1e9d)


`Netty`는 프로토콜 서버 및 클라이언트와 같은 네트워크 응용 프로그램을 빠르고 쉽게 개발할 수있는 NIO 클라이언트 서버 프레임 워크입니다. TCP 및 UDP 소켓 서버와 같은 네트워크 프로그래밍을 크게 단순화하고 간소화합니다.

`Netty 컴포넌트` 

이러한 NIO 네트워크 기반 Netty 프레임워크는 비동기식 이벤트 기반 네트워킹을 지원합니다.

Tomcat서버가 10,000건의 커넥션을 처리한다면, netty는 100,000건에서 1,000,000건의 커넥션을 처리할 수 있는 장점이 있습니다.

핵심 컴포넌트로는 `Channel`, `CallBack`, `Future`, `이벤트와 핸들러`, `Event Loop`와 `PipeLine`이 있습니다.

**Channel** : 하나 이상의 입출력 작업을 수행할 수 있는 하드웨어 장치, 파일, 네트워크 소켓이나 프로그램 컴포넌트와 같은 Open된 Connection 을 의미합니다.

**CallBack** : 다른 메서드로 자신에 대한 참조를 제공하는 메서드입니다. 이벤트를 처리할 때 Netty 내부적으로 콜백을 이용하는데, 이때 ChannelHandler 인터페이스를 통해 이벤트를 처리합니다.

**Future** : 작업이 완료가 될 경우 애플리케이션에 알립니다. Future 객체는 비동기 작업의 결과를 담는 Plachloder의 역할을 합니다. 이때 ChannelFuture 인터페이스를 이용해 결과값을 활용합니다.

**Event와 Handler** : Netty는 작업 상태의 변화를 알리기 위해 이벤트를 이용하고, 발생한 이벤트를 기준으로 Handler를 통해 트리거합니다.
